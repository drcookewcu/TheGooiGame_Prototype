using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace FractalTree
{
	/// <summary>
	/// A stationary branch. Forces cannot be applied to it. It is a line drawn onscreen by rotating and scaling a sprite between a start and end point.
	/// </summary>
	public class StationaryBranch : MonoBehaviour, Branch
	{
		/// <summary>
		/// Used by the default tree algorithm. Each branchings length is multiplied by this value.
		/// </summary>
		public static float LengthDegradation = 0.67f;

		/// <summary>
		/// Gets or sets the colonization direction. Used for space colonization tree generation. Defines the direction of the
		/// next branch in relation
		/// to nearby leaves.
		/// </summary>
		/// <value>The colonization dir.</value>
		public Vector2 colonizationDir { get; set; }

		/// <summary>
		/// Gets or sets the number of nearby colonizaion leaves.
		/// </summary>
		/// <value>The colonization leaf count.</value>
		public int colonizationLeafCount { get; set; }

		/// <summary>
		/// Gets the start position.
		/// </summary>
		/// <value>The start position.</value>
		public virtual Vector2 startPos { get; private set; }

		/// <summary>
		/// Gets the end position.
		/// </summary>
		/// <value>The end position.</value>
		public virtual Vector2 endPos { get; private set; }

		/// <summary>
		/// Gets or sets a value indicating whether this <see cref="FractalTree.StationaryBranch"/> has branched.
		/// </summary>
		/// <value><c>true</c> if has branched; otherwise, <c>false</c>.</value>
		public bool hasBranched { get; set; }

		/// <summary>
		/// Sets the color of the branch sprite and updates the sprite renderer.
		/// </summary>
		/// <value>The color.</value>
		public Color color {
			set {
				UpdateColor (value);
			}
		}

		/// <summary>
		/// Pixels of line sprite / pixels per units.
		/// </summary>
		protected static readonly float SPRITE_SIZE = 100f / 100f;

		/// <summary>
		/// The width of the branch.
		/// </summary>
		protected float m_Width;

		/// <summary>
		/// The renderer associated with the branch.
		/// </summary>
		protected SpriteRenderer m_Renderer;

		protected virtual void Awake ()
		{
			m_Renderer = GetComponent<SpriteRenderer> ();
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch.
		/// </summary>
		/// <param name="owner">The attached branch.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		public virtual void Setup (Branch owner, Vector2 end,
		                        float thickness, Color color)
		{
			Setup (owner.endPos, end, thickness, color, false);
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch
		/// that has its mass autogenerated based on line width.
		/// </summary>
		/// <param name="owner">Owner.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		/// <param name="autoMass">If set to <c>true</c> auto mass.</param>
		public virtual void Setup (Branch owner, Vector2 end,
		                        float thickness, Color color, bool autoMass)
		{
			Setup (owner.endPos, end, thickness, color, autoMass);
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch.
		/// </summary>
		/// <param name="owner">The attached branch.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		/// <param name="start">Start.</param>
		public virtual void Setup (Vector2 start, Vector2 end,
		                        float thickness, Color color)
		{
			Setup (start, end, thickness, color, false);
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch
		/// that has its mass autogenerated based on line width.
		/// </summary>
		/// <param name="owner">Owner.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		/// <param name="start">Start.</param>
		/// <param name="autoMass">If set to <c>true</c> auto mass.</param>
		public virtual void Setup (Vector2 start, Vector2 end,
		                        float thickness, Color color, bool autoMass)
		{
			this.m_Width = thickness;
			startPos = start;
			endPos = end;
			this.color = color;

			colonizationDir = end - start;
			colonizationLeafCount = 0;

			UpdateSprite ();
			UpdateColor (color);
		}

		/// <summary>
		/// Returns a new branch based on current branch angle plus parameter angle.
		/// </summary>
		/// <returns>The branching.</returns>
		/// <param name="angle">Angle.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public T DoBranching<T> (float angle) where T : Branch
		{
			var newBranch = ((GameObject)Instantiate (gameObject)).GetComponent<T> ();

			var dir = (endPos - startPos) * LengthDegradation;
			var dirRot = dir.Rotate (angle);
			var newEnd = endPos + dirRot;

			newBranch.Setup (this, newEnd, this.m_Width, m_Renderer.color);

			return newBranch;
		}

		/// <summary>
		/// Updates the sprite position, rotation, and scale in relation to the start and point.
		/// </summary>
		protected void UpdateSprite ()
		{
			var heading = endPos - startPos;
			var distance = heading.magnitude;
			var direction = heading / distance;

			var centerPos = new Vector2 (
				                         startPos.x + endPos.x,
				                         startPos.y + endPos.y) * 0.5f;

			m_Renderer.transform.position = centerPos;

			// angle
			float angle = Mathf.Atan2 (direction.y, direction.x) * Mathf.Rad2Deg;
			m_Renderer.transform.rotation = Quaternion.AngleAxis (angle, Vector3.forward);

			//length
			m_Renderer.transform.localScale = new Vector3 (distance / SPRITE_SIZE + 0.0041f, m_Width, m_Renderer.transform.localScale.z);

		}

		/// <summary>
		/// Resets the colonization paramater. Used only for space colonization generation.
		/// </summary>
		public void DoColonizationReset()
		{
			colonizationDir = endPos - startPos;
			colonizationLeafCount = 0;
		}

		/// <summary>
		/// Updates the sprite renderer color.
		/// </summary>
		/// <param name="color">Color.</param>
		protected void UpdateColor (Color color)
		{
			m_Renderer.color = color;
		}
	}
}