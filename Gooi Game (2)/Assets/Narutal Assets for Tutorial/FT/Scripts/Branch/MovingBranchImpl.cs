using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace FractalTree
{
	/// <summary>
	/// Extends a normal branch and adds spring functionality. Force can be applied to the start and end point of the branch.
	/// </summary>
	[RequireComponent (typeof(SpriteRenderer), typeof(Spring))]
	public class MovingBranchImpl : StationaryBranch, MovingBranch
	{
		/// <summary>
		/// Gets the start point mass. Used to add spring force
		/// </summary>
		/// <value>The start point.</value>
		public PointMass startPoint { get { return m_Spring.start; } }

		/// <summary>
		/// Gets the end point mass. Used to add spring force.
		/// </summary>
		/// <value>The end point.</value>
		public PointMass endPoint { get { return m_Spring.end; } }

		/// <summary>
		/// Gets the start position.
		/// </summary>
		/// <value>The start position.</value>
		public override Vector2 startPos { get { return startPoint.position; }}

		/// <summary>
		/// Gets the end position.
		/// </summary>
		/// <value>The end position.</value>
		public override Vector2 endPos { get { return endPoint.position; } }

		private Spring m_Spring;

		private Branch m_Owner;

		protected override void Awake ()
		{
			base.Awake ();
			m_Spring = GetComponent<Spring> ();
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch.
		/// </summary>
		/// <param name="owner">The attached branch.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		public override void Setup (Branch owner, Vector2 end,
		                        float thickness, Color color)
		{
			m_Owner = owner;

			Setup (owner.endPos, end, thickness, color);
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch
		/// that has its mass autogenerated based on line width.
		/// </summary>
		/// <param name="owner">Owner.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		/// <param name="autoMass">If set to <c>true</c> auto mass.</param>
		public override void Setup (Branch owner, Vector2 end,
		                        float thickness, Color color, bool autoMass)
		{
			m_Owner = owner;

			Setup (owner.endPos, end, thickness, color, autoMass);
		}
			
		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch.
		/// </summary>
		/// <param name="owner">The attached branch.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		/// <param name="start">Start.</param>
		public override void Setup (Vector2 start, Vector2 end,
			float thickness, Color color)
		{
			Setup (start, end, thickness, color, false);
		}

		/// <summary>
		/// Setup the specified owner, end, thickness and color. Used to create a branch that is attached to another branch
		/// that has its mass autogenerated based on line width.
		/// </summary>
		/// <param name="owner">Owner.</param>
		/// <param name="end">End.</param>
		/// <param name="thickness">Thickness.</param>
		/// <param name="color">Color.</param>
		/// <param name="start">Start.</param>
		/// <param name="width">Width.</param>
		/// <param name="autoMass">If set to <c>true</c> auto mass.</param>
		public override void Setup (Vector2 start, Vector2 end,
		                        float width, Color color, bool autoMass)
		{
			this.m_Width = width;
			this.color = color;
			const float stiffness = 0.1f;
			const float damping = 0.96f;
			const float stationary = 0f;
			float moveable = autoMass ? 1f * (width) : 0.1f;
			const float bounceBackForce = 0.5f;

			m_Spring.Setup (new PointMass (start, stationary, bounceBackForce),
				new PointMass (end, moveable, bounceBackForce), stiffness, damping);

			colonizationDir = end - start;
			colonizationLeafCount = 0;

			UpdateSprite ();
			UpdateColor (color);
		}

		/// <summary>
		/// Returns a new branch based on current branch angle plus parameter angle.
		/// </summary>
		/// <returns>The branching.</returns>
		/// <param name="angle">Angle.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		new public T DoBranching<T> (float angle) where T : Branch
		{
			var newBranch = ((GameObject)Instantiate (gameObject)).GetComponent<T> ();

			var dir = (endPoint.position - startPoint.position) * LengthDegradation;
			var dirRot = dir.Rotate (angle);
			var newEnd = endPoint.position + dirRot;

			newBranch.Setup (this, newEnd, this.m_Width, m_Renderer.color);

			return newBranch;
		}

		/// <summary>
		/// Update this instance. Locks position to owners position. Updates start and end point force, and if a force has been applied updates the spring and
		/// sprite position.
		/// </summary>
		void Update ()
		{
			bool updateReq = false;

			if (m_Owner != null) {
				if (startPoint.position != m_Owner.endPos) {
					startPoint.position = m_Owner.endPos;
					updateReq = true;
				}

			}


			startPoint.DoUpdate ();
			endPoint.DoUpdate ();

 
			if (updateReq || startPoint.forceApplied || endPoint.forceApplied) {
				m_Spring.DoUpdate ();
				UpdateSprite ();
			}

		}

	}
}